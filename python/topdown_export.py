"""Top-Down exporter for Python.

Generates a static Python module containing Top-Down rows, so runtime code
doesn't need to read `.topdown/config.json`.

Example:

    python topdown_export.py --out .topdown/generated/topdown_defs.py

Then in Python:

    from .topdown.generated.topdown_defs import TOPDOWN_ROWS
"""

from __future__ import annotations

import argparse
from pathlib import Path
from typing import Any

from topdown_runtime import STORE_RELATIVE, find_topdown_root


def export_python_module(out_path: Path, *, root: str | None = None) -> None:
    project_root = find_topdown_root(root)
    config_path = project_root / STORE_RELATIVE
    data = config_path.read_text("utf-8")

    # Keep it simple: embed the parsed JSON as a literal dict.
    import json

    store = json.loads(data)
    rows = store.get("rows") if isinstance(store, dict) else None
    if not isinstance(rows, list):
        rows = []

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text(
        """# Generated by Top-Down (do not edit by hand)
TOPDOWN_ROWS = """
        + repr(rows)
        + "\n",
        encoding="utf-8",
    )


def main(argv: list[str] | None = None) -> int:
    p = argparse.ArgumentParser()
    p.add_argument("--out", required=True, help="Output .py file path")
    p.add_argument("--root", default=None, help="Project root (optional; otherwise auto-detected)")
    args = p.parse_args(argv)

    export_python_module(Path(args.out), root=args.root)
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
